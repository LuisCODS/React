{"ast":null,"code":"var _jsxFileName = \"/Users/luissantos/Desktop/React and Next/shopping-list/src/App.js\",\n  _s = $RefreshSig$();\nimport Header from './components/Header';\nimport Main from './components/Main';\nimport Footer from './components/Footer';\nimport { useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [items, setItems] = useState([]);\n  function addItem(newItem) {\n    /*\n      On utilise la syntaxe de décomposition [...items, newItem] au lieu de push() car:\n      1. React exige l'immutabilité - on ne doit pas modifier directement le state\n      2. push() modifie le tableau original, ce qui peut causer des bugs\n      3. [...items, newItem] crée une nouvelle copie du tableau avec le nouvel élément\n      4. Cela garantit que React détecte le changement et re-render correctement\n    */\n    setItems(items => [...items, newItem]);\n  }\n  ;\n  function deleteItem(id) {\n    /*\n      filtre et met à jour la liste des items:\n      1. setItems est la fonction de mise à jour du state fournie par useState\n      2. On utilise filter() qui crée un nouveau tableau avec les éléments qui passent le test\n      3. La condition item.id !== id garde tous les items SAUF celui avec l'id correspondant\n      4. Cela supprime effectivement l'item avec l'id spécifié de la liste\n      5. On utilise une fonction callback pour garantir l'accès au state le plus récent\n    */\n    setItems(items => items.filter(item => item.id !== id));\n  }\n  ;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"appWrapper\",\n    children: [/*#__PURE__*/_jsxDEV(Header, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 34,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Main, {\n      items: items,\n      addItem: addItem\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Footer, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 36,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 33,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"6WAym07vHedVzpAy8bFDJKqtv8I=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["Header","Main","Footer","useState","jsxDEV","_jsxDEV","App","_s","items","setItems","addItem","newItem","deleteItem","id","filter","item","className","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/luissantos/Desktop/React and Next/shopping-list/src/App.js"],"sourcesContent":["import Header from './components/Header';\nimport Main from './components/Main';\nimport Footer from './components/Footer';\nimport { useState } from \"react\";\n\nfunction App() {\n  const [items, setItems] = useState([]);\n\n  function addItem(newItem) {\n    /*\n      On utilise la syntaxe de décomposition [...items, newItem] au lieu de push() car:\n      1. React exige l'immutabilité - on ne doit pas modifier directement le state\n      2. push() modifie le tableau original, ce qui peut causer des bugs\n      3. [...items, newItem] crée une nouvelle copie du tableau avec le nouvel élément\n      4. Cela garantit que React détecte le changement et re-render correctement\n    */\n    setItems((items) => [...items, newItem]);\n  };\n\n  function deleteItem(id) {\n    /*\n      filtre et met à jour la liste des items:\n      1. setItems est la fonction de mise à jour du state fournie par useState\n      2. On utilise filter() qui crée un nouveau tableau avec les éléments qui passent le test\n      3. La condition item.id !== id garde tous les items SAUF celui avec l'id correspondant\n      4. Cela supprime effectivement l'item avec l'id spécifié de la liste\n      5. On utilise une fonction callback pour garantir l'accès au state le plus récent\n    */\n    setItems((items) => items.filter((item) => item.id !== id));\n  };\n\n  return (\n    <div className=\"appWrapper\">\n      <Header />\n      <Main items={ items } addItem = { addItem } />\n      <Footer />\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":";;AAAA,OAAOA,MAAM,MAAM,qBAAqB;AACxC,OAAOC,IAAI,MAAM,mBAAmB;AACpC,OAAOC,MAAM,MAAM,qBAAqB;AACxC,SAASC,QAAQ,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEjC,SAASC,GAAGA,CAAA,EAAG;EAAAC,EAAA;EACb,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGN,QAAQ,CAAC,EAAE,CAAC;EAEtC,SAASO,OAAOA,CAACC,OAAO,EAAE;IACxB;AACJ;AACA;AACA;AACA;AACA;AACA;IACIF,QAAQ,CAAED,KAAK,IAAK,CAAC,GAAGA,KAAK,EAAEG,OAAO,CAAC,CAAC;EAC1C;EAAC;EAED,SAASC,UAAUA,CAACC,EAAE,EAAE;IACtB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIJ,QAAQ,CAAED,KAAK,IAAKA,KAAK,CAACM,MAAM,CAAEC,IAAI,IAAKA,IAAI,CAACF,EAAE,KAAKA,EAAE,CAAC,CAAC;EAC7D;EAAC;EAED,oBACER,OAAA;IAAKW,SAAS,EAAC,YAAY;IAAAC,QAAA,gBACzBZ,OAAA,CAACL,MAAM;MAAAkB,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC,eACVhB,OAAA,CAACJ,IAAI;MAACO,KAAK,EAAGA,KAAO;MAACE,OAAO,EAAKA;IAAS;MAAAQ,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC,eAC9ChB,OAAA,CAACH,MAAM;MAAAgB,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACP,CAAC;AAEV;AAACd,EAAA,CAjCQD,GAAG;AAAAgB,EAAA,GAAHhB,GAAG;AAmCZ,eAAeA,GAAG;AAAC,IAAAgB,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}